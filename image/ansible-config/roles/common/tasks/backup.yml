---
- name: Validate backup transport
  ansible.builtin.assert:
    that:
      - backup_transport in ['cli', 'netconf', 'httpapi', 'scp']
    fail_msg: "backup_transport must be one of: cli, netconf, httpapi, scp"

- name: Validate CLI backup command
  ansible.builtin.assert:
    that:
      - backup_command | length > 0
    fail_msg: "backup_command must be set for CLI backups"
  when: backup_transport == 'cli'

- name: Validate HTTP API backup settings
  ansible.builtin.assert:
    that:
      - httpapi_base_url | length > 0
      - httpapi_backup_path | length > 0
    fail_msg: "httpapi_base_url and httpapi_backup_path must be set for HTTP API backups"
  when: backup_transport == 'httpapi'

- name: Validate SCP backup settings
  ansible.builtin.assert:
    that:
      - (scp_backup_path | default('') | length > 0) or (scp_remote_path | default('') | length > 0)
    fail_msg: "scp_backup_path or scp_remote_path must be set for SCP backups"
  when: backup_transport == 'scp'

- name: Collect running config via CLI
  ansible.builtin.include_tasks: backup_cli.yml
  when: backup_transport == 'cli'

- name: Collect running config via NETCONF
  ansible.builtin.include_tasks: backup_netconf.yml
  when: backup_transport == 'netconf'

- name: Collect running config via HTTP API
  ansible.builtin.include_tasks: backup_httpapi.yml
  when: backup_transport == 'httpapi'

- name: Collect running config via SCP
  ansible.builtin.include_tasks: backup_scp.yml
  when: backup_transport == 'scp'

- name: Ensure a config payload was collected
  ansible.builtin.assert:
    that:
      - raw_config is defined
      - raw_config | length > 0
    fail_msg: "No configuration data was collected from the device."

- name: Normalize raw config
  ansible.builtin.set_fact:
    normalized_config: "{{ raw_config | string | regex_replace('\\r', '') }}"

- name: Strip volatile lines
  ansible.builtin.set_fact:
    normalized_config: "{{ normalized_config | regex_replace('(?m)' ~ item ~ '\\n?', '') }}"
  loop: "{{ normalize_patterns | default([]) }}"

- name: Collapse excessive blank lines
  ansible.builtin.set_fact:
    normalized_config: "{{ normalized_config | regex_replace('\\n{3,}', '\\n\\n') }}"
  when: normalize_strip_empty | default(true)

- name: Resolve backup template
  ansible.builtin.set_fact:
    _backup_template: "{{ backup_filename_template | default('') }}"

- name: Resolve backup template flag
  ansible.builtin.set_fact:
    _backup_template_enabled: "{{ (_backup_template | trim | length) > 0 }}"

- name: Resolve backup timestamp
  ansible.builtin.set_fact:
    backup_timestamp: "{{ backup_timestamp | default(lookup('pipe', 'date -u +%Y%m%d%H%M%S')) }}"
  when: _backup_template_enabled

- name: Resolve backup filename
  ansible.builtin.set_fact:
    backup_filename_effective: >-
      {{
        _backup_template_enabled
        | ternary(
            (_backup_template
              | replace('<clab_lab_name>', clab_lab_name | default('lab'))
              | replace('<ne_name>', inventory_hostname)
              | replace('<time-stamp>', backup_timestamp | default(''))),
            backup_filename
          )
      }}

- name: Ensure backup directory exists
  ansible.builtin.file:
    path: "{{ backup_root }}/{{ inventory_hostname }}"
    state: directory
    mode: "0750"
  delegate_to: localhost
  when: backup_write | default(true)

- name: Write running config to backups directory
  ansible.builtin.copy:
    dest: "{{ backup_root }}/{{ inventory_hostname }}/{{ backup_filename_effective | default(backup_filename) }}"
    content: "{{ normalized_config | trim }}\n"
    mode: "0640"
  delegate_to: localhost
  when: backup_write | default(true)

- name: Write latest running config (stable filename)
  ansible.builtin.copy:
    dest: "{{ backup_root }}/{{ inventory_hostname }}/{{ backup_filename }}"
    content: "{{ normalized_config | trim }}\n"
    mode: "0640"
  delegate_to: localhost
  when:
    - backup_write | default(true)
    - backup_write_latest | default(true)
    - (backup_filename_effective | default(backup_filename)) != backup_filename
